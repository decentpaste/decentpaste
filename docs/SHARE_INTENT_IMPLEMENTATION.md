# Share Intent Implementation Guide

**Purpose**: Enable users to share text from any mobile app directly to DecentPaste via the OS share menu.

**Target Platforms**: Android and iOS

**Approach**: Tauri v2 Plugin to avoid modifying generated source directories

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Codebase Context](#2-codebase-context)
3. [Architecture Overview](#3-architecture-overview)
4. [Plugin Structure](#4-plugin-structure)
5. [Android Implementation](#5-android-implementation)
6. [iOS Implementation](#6-ios-implementation)
7. [Rust Plugin Core](#7-rust-plugin-core)
8. [App Integration](#8-app-integration)
9. [Frontend Integration](#9-frontend-integration)
10. [Testing](#10-testing)
11. [Implementation Checklist](#11-implementation-checklist)

---

## 1. Executive Summary

### Goal
When a user selects text in any app and taps "Share" → "DecentPaste":
1. DecentPaste opens (cold start) or resumes (warm start)
2. The shared content is stored
3. App reconnects to paired peers
4. Content is encrypted and broadcast to all paired devices
5. User sees confirmation toast

### Why a Plugin?
- The `gen/android/` and `gen/apple/` directories are **generated by Tauri** and can be regenerated
- Modifications to these directories would be lost on `tauri android init` or `tauri ios init`
- Tauri plugins include native code that gets **merged** into the build automatically
- This keeps all share intent logic isolated and maintainable

### Key Components to Reuse
The app already has these components that the plugin will leverage:
- `share_clipboard_content` command - Encrypts and broadcasts to peers
- `reconnect_peers` command - Reconnects to discovered peers
- Mobile resume flow - Already handles foreground/background transitions
- `PendingClipboard` pattern - Template for pending share content

---

## 2. Codebase Context

### Project Structure
```
decentpaste/
├── decentpaste-app/
│   ├── src/                          # Frontend (TypeScript)
│   │   ├── main.ts                   # Entry point, visibility handling
│   │   ├── app.ts                    # Main UI, vault status handling
│   │   ├── api/
│   │   │   ├── commands.ts           # Tauri command wrappers
│   │   │   └── events.ts             # Event listeners
│   │   └── state/
│   │       └── store.ts              # Reactive state management
│   └── src-tauri/
│       ├── Cargo.toml                # Rust dependencies
│       ├── tauri.conf.json           # Tauri configuration
│       ├── src/
│       │   ├── lib.rs                # App initialization, plugin registration
│       │   ├── commands.rs           # All Tauri commands
│       │   ├── state.rs              # AppState with Arc<RwLock<>> fields
│       │   ├── error.rs              # Error types
│       │   ├── network/              # libp2p networking
│       │   ├── clipboard/            # Clipboard monitoring
│       │   ├── security/             # Encryption, pairing
│       │   └── vault/                # Stronghold encrypted storage
│       ├── gen/
│       │   ├── android/              # Generated Android project (DO NOT MODIFY)
│       │   └── apple/                # Generated iOS project (DO NOT MODIFY)
│       └── plugins/                  # Custom plugins (CREATE HERE)
│           └── tauri-plugin-share-intent/  # New plugin
```

### Key Existing Code

#### AppState (state.rs)
```rust
pub struct AppState {
    pub device_identity: Arc<RwLock<Option<DeviceIdentity>>>,
    pub paired_peers: Arc<RwLock<Vec<PairedPeer>>>,
    pub clipboard_history: Arc<RwLock<Vec<ClipboardEntry>>>,
    pub network_command_tx: Arc<RwLock<Option<mpsc::Sender<NetworkCommand>>>>,
    pub pending_clipboard: Arc<RwLock<Option<PendingClipboard>>>,  // Pattern to follow
    pub is_foreground: Arc<RwLock<bool>>,
    pub vault_status: Arc<RwLock<VaultStatus>>,
    pub vault_manager: Arc<RwLock<Option<VaultManager>>>,
}
```

#### share_clipboard_content Command (commands.rs:442-516)
This is the main function to reuse. It:
1. Validates content size (max 1MB)
2. Gets device identity from state
3. Gets all paired peers
4. For each peer, encrypts content with their shared secret
5. Broadcasts via NetworkCommand::BroadcastClipboard
6. Adds entry to clipboard history
7. Emits `clipboard-sent` event

```rust
#[tauri::command]
pub async fn share_clipboard_content(
    app: AppHandle,
    state: State<'_, AppState>,
    content: String,
) -> Result<u32> {
    const MAX_CLIPBOARD_SIZE: usize = 1024 * 1024;
    if content.len() > MAX_CLIPBOARD_SIZE {
        return Err(DecentPasteError::InvalidInput("Content too large".into()));
    }

    let content_hash = hash_content(&content);
    let device_identity = state.device_identity.read().await;
    let identity = device_identity.as_ref().ok_or(DecentPasteError::NotInitialized)?;

    let paired_peers = state.paired_peers.read().await;
    if paired_peers.is_empty() {
        return Err(DecentPasteError::Pairing("No paired peers".into()));
    }

    let tx = state.network_command_tx.read().await;
    let mut broadcast_count = 0u32;

    for peer in paired_peers.iter() {
        let encrypted = encrypt_content(content.as_bytes(), &peer.shared_secret)?;
        let msg = ClipboardMessage { /* ... */ };
        if let Some(tx) = tx.as_ref() {
            if tx.send(NetworkCommand::BroadcastClipboard { message: msg }).await.is_ok() {
                broadcast_count += 1;
            }
        }
    }

    // Add to history, emit event
    Ok(broadcast_count)
}
```

#### Mobile Resume Flow (lib.rs:138-208)
```rust
tauri::RunEvent::Resumed => {
    // App came to foreground
    let state = app.state::<AppState>();
    *state.is_foreground.blocking_write() = true;

    // Reconnect to peers
    if let Some(tx) = state.network_command_tx.blocking_read().as_ref() {
        let _ = tx.blocking_send(NetworkCommand::ReconnectPeers);
    }

    // Process pending clipboard (existing pattern)
    #[cfg(any(target_os = "android", target_os = "ios"))]
    if let Some(pending) = state.pending_clipboard.blocking_write().take() {
        // Apply clipboard...
    }
}
```

#### Frontend Visibility Handling (main.ts:25-61)
```typescript
document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible') {
        store.set('isWindowVisible', true);
        await reconnectPeers();
        const pending = await processPendingClipboard();
        if (pending) {
            store.addToast(`Clipboard synced from ${pending.from_device}`, 'success');
        }
    } else {
        await flushVault();
    }
});
```

### Vault States
The app has three vault states that affect share intent handling:
- `NotSetup` - First run, needs onboarding
- `Locked` - Vault exists but needs PIN
- `Unlocked` - Ready to share

**Critical**: Content can only be shared when vault is `Unlocked`. If locked, store content and process after unlock.

---

## 3. Architecture Overview

### Data Flow Diagram
```
┌─────────────────────────────────────────────────────────────────────────────┐
│                              OTHER APP                                       │
│                         (User selects text)                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           OS SHARE MENU                                      │
│                    (User selects DecentPaste)                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
          ┌─────────────────────────┴─────────────────────────┐
          │                                                   │
          ▼                                                   ▼
┌──────────────────────┐                        ┌──────────────────────┐
│       ANDROID        │                        │         iOS          │
│   ShareIntentPlugin  │                        │   ShareExtension +   │
│      (Kotlin)        │                        │   ShareIntentPlugin  │
└──────────────────────┘                        └──────────────────────┘
          │                                                   │
          │ onNewIntent / onCreate                            │ App Groups
          │ ACTION_SEND                                       │ UserDefaults
          ▼                                                   ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         PLUGIN RUST CORE                                     │
│                    tauri-plugin-share-intent                                 │
│                                                                              │
│   • Emits "share-intent-received" event to frontend                         │
│   • Provides get_pending_content command                                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                           FRONTEND (TypeScript)                              │
│                              main.ts / app.ts                                │
│                                                                              │
│   listen('share-intent-received') → handleShareIntent(content)              │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                    ┌───────────────┴───────────────┐
                    ▼                               ▼
          ┌─────────────────┐             ┌─────────────────┐
          │  VAULT LOCKED   │             │ VAULT UNLOCKED  │
          └─────────────────┘             └─────────────────┘
                    │                               │
                    ▼                               ▼
          Store pending content           Reconnect peers
          Show unlock screen              ▼
          ─────────────────►              Call share_clipboard_content
          After unlock, process           ▼
                                          Show success toast
                                          "Shared with X devices"
```

### Two Launch Scenarios

**Cold Start** (app not running):
1. Android: `onCreate()` receives intent with `ACTION_SEND`
2. iOS: Extension writes to App Groups, main app reads on launch
3. Plugin emits event after WebView loads
4. Frontend handles event

**Warm Start** (app in background):
1. Android: `onNewIntent()` receives intent
2. iOS: Main app checks App Groups on `visibilitychange`
3. Plugin emits event immediately
4. Frontend handles event

---

## 4. Plugin Structure

### Directory Layout
Create this structure at `decentpaste-app/src-tauri/plugins/tauri-plugin-share-intent/`:

```
tauri-plugin-share-intent/
├── Cargo.toml
├── build.rs
├── src/
│   ├── lib.rs
│   ├── commands.rs
│   ├── mobile.rs
│   └── error.rs
├── android/
│   ├── build.gradle.kts
│   ├── proguard-rules.pro
│   └── src/main/
│       ├── AndroidManifest.xml
│       └── kotlin/com/decentpaste/plugins/shareintent/
│           └── ShareIntentPlugin.kt
├── ios/
│   ├── Package.swift
│   ├── Sources/ShareIntentPlugin/
│   │   └── ShareIntentPlugin.swift
│   └── ShareExtension/              # iOS Share Extension (separate target)
│       ├── Info.plist
│       ├── ShareExtension.entitlements
│       └── ShareViewController.swift
└── permissions/
    └── default.toml
```

### File Contents

#### Cargo.toml
```toml
[package]
name = "tauri-plugin-share-intent"
version = "0.1.0"
edition = "2021"
description = "Tauri plugin for handling share intents on mobile"
license = "MIT"
authors = ["DecentPaste Team"]

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
tauri = "2"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"
log = "0.4"

[target.'cfg(target_os = "android")'.dependencies]
jni = "0.21"

[build-dependencies]
tauri-plugin = { version = "2", features = ["build"] }
```

#### build.rs
```rust
const COMMANDS: &[&str] = &["get_pending_content"];

fn main() {
    tauri_plugin::Builder::new(COMMANDS)
        .android_path("android")
        .ios_path("ios")
        .build();
}
```

---

## 5. Android Implementation

### AndroidManifest.xml
**File**: `android/src/main/AndroidManifest.xml`

This manifest gets **merged** with the app's manifest at build time.

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.decentpaste.plugins.shareintent">

    <!-- This intent filter will be merged into MainActivity -->
    <application>
        <activity
            android:name="app.tauri.activity.TauriActivity"
            tools:node="merge">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="text/plain" />
            </intent-filter>
        </activity>
    </application>

</manifest>
```

**Note**: The `tools:node="merge"` attribute tells the manifest merger to combine this with existing activity definitions.

### build.gradle.kts
**File**: `android/build.gradle.kts`

```kotlin
plugins {
    id("com.android.library")
    id("org.jetbrains.kotlin.android")
}

android {
    namespace = "com.decentpaste.plugins.shareintent"
    compileSdk = 34

    defaultConfig {
        minSdk = 24
        targetSdk = 34
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    kotlinOptions {
        jvmTarget = "1.8"
    }
}

dependencies {
    implementation("androidx.core:core-ktx:1.12.0")
    implementation(project(":tauri-android"))
}
```

### Kotlin Plugin Class
**File**: `android/src/main/kotlin/com/decentpaste/plugins/shareintent/ShareIntentPlugin.kt`

```kotlin
package com.decentpaste.plugins.shareintent

import android.app.Activity
import android.content.Intent
import android.webkit.WebView
import app.tauri.annotation.Command
import app.tauri.annotation.TauriPlugin
import app.tauri.plugin.Invoke
import app.tauri.plugin.JSObject
import app.tauri.plugin.Plugin

@TauriPlugin
class ShareIntentPlugin(private val activity: Activity) : Plugin(activity) {

    // Store pending content for retrieval by Rust/JS
    private var pendingContent: String? = null

    // Track if we've already emitted for this content (prevent duplicates)
    private var lastEmittedContent: String? = null

    /**
     * Called when the plugin is loaded and WebView is ready.
     * Check for share intent that launched the app (cold start).
     */
    override fun load(webView: WebView) {
        super.load(webView)
        // Handle intent that started the activity
        handleIntent(activity.intent)
    }

    /**
     * Called when the activity receives a new intent while running (warm start).
     * This happens when user shares to the app while it's in background.
     */
    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        handleIntent(intent)
    }

    /**
     * Process an intent and extract shared text if present.
     */
    private fun handleIntent(intent: Intent?) {
        if (intent == null) return

        // Check if this is a share intent
        if (intent.action == Intent.ACTION_SEND && intent.type == "text/plain") {
            val sharedText = intent.getStringExtra(Intent.EXTRA_TEXT)

            if (!sharedText.isNullOrEmpty()) {
                // Store for retrieval
                pendingContent = sharedText

                // Only emit if this is new content (prevent duplicate events)
                if (sharedText != lastEmittedContent) {
                    lastEmittedContent = sharedText

                    // Emit event to frontend
                    val payload = JSObject()
                    payload.put("content", sharedText)
                    payload.put("source", "android")
                    trigger("share-intent-received", payload)
                }
            }
        }

        // Clear the intent action to prevent re-processing on config changes
        intent.action = null
    }

    /**
     * Command to get pending share content.
     * Called from Rust/JS to retrieve and consume the pending content.
     */
    @Command
    fun getPendingContent(invoke: Invoke) {
        val result = JSObject()

        if (pendingContent != null) {
            result.put("content", pendingContent)
            result.put("source", "android")
            pendingContent = null  // Consume the content
        } else {
            result.put("content", JSObject.NULL)
            result.put("source", JSObject.NULL)
        }

        invoke.resolve(result)
    }

    /**
     * Command to check if there's pending content without consuming it.
     */
    @Command
    fun hasPendingContent(invoke: Invoke) {
        val result = JSObject()
        result.put("hasPending", pendingContent != null)
        invoke.resolve(result)
    }

    /**
     * Command to clear pending content without processing.
     */
    @Command
    fun clearPendingContent(invoke: Invoke) {
        pendingContent = null
        lastEmittedContent = null
        invoke.resolve(JSObject())
    }
}
```

### proguard-rules.pro
**File**: `android/proguard-rules.pro`

```proguard
# Keep Tauri plugin classes
-keep class com.decentpaste.plugins.shareintent.** { *; }
-keep class app.tauri.** { *; }

# Keep annotations
-keepattributes *Annotation*
```

---

## 6. iOS Implementation

iOS requires two components:
1. **ShareIntentPlugin** - Main app plugin that checks for pending content
2. **Share Extension** - Separate iOS target that receives share intents

### Share Extension Overview

iOS Share Extensions run in a **separate process** with:
- 120MB memory limit
- No access to main app's sandbox
- Limited execution time (a few seconds)

To communicate between extension and main app:
1. Configure **App Groups** on both targets
2. Extension writes to shared `UserDefaults`
3. Main app reads from shared `UserDefaults` on launch/resume

### Plugin Swift Code
**File**: `ios/Sources/ShareIntentPlugin/ShareIntentPlugin.swift`

```swift
import Foundation
import Tauri
import WebKit

class ShareIntentPlugin: Plugin {

    // App Group identifier - must match extension
    private static let appGroupId = "group.com.decentpaste.application"
    private static let pendingContentKey = "shareIntent_pendingContent"
    private static let pendingTimestampKey = "shareIntent_timestamp"

    // Track last emitted content to prevent duplicates
    private var lastEmittedContent: String?

    // MARK: - Plugin Lifecycle

    override func load(webview: WKWebView) {
        super.load(webview: webview)

        // Check for pending content from Share Extension (cold start)
        checkPendingContent()
    }

    /// Called when app becomes active (warm start, returning from background)
    @objc func applicationDidBecomeActive() {
        checkPendingContent()
    }

    // MARK: - Content Handling

    /// Check for pending content in App Group shared storage
    private func checkPendingContent() {
        guard let defaults = UserDefaults(suiteName: Self.appGroupId) else {
            print("[ShareIntentPlugin] Failed to access App Group defaults")
            return
        }

        // Check if there's pending content
        guard let content = defaults.string(forKey: Self.pendingContentKey) else {
            return
        }

        // Check timestamp - expire after 5 minutes
        if let timestamp = defaults.object(forKey: Self.pendingTimestampKey) as? Date {
            let fiveMinutesAgo = Date().addingTimeInterval(-300)
            if timestamp < fiveMinutesAgo {
                // Content is stale, clear it
                clearPendingContent()
                return
            }
        }

        // Prevent duplicate emissions
        if content == lastEmittedContent {
            return
        }
        lastEmittedContent = content

        // Emit event to frontend
        trigger("share-intent-received", data: [
            "content": content,
            "source": "ios"
        ])
    }

    /// Clear pending content from shared storage
    private func clearPendingContent() {
        guard let defaults = UserDefaults(suiteName: Self.appGroupId) else { return }
        defaults.removeObject(forKey: Self.pendingContentKey)
        defaults.removeObject(forKey: Self.pendingTimestampKey)
        defaults.synchronize()
    }

    // MARK: - Commands

    /// Get and consume pending content
    @objc public func getPendingContent(_ invoke: Invoke) throws {
        guard let defaults = UserDefaults(suiteName: Self.appGroupId) else {
            invoke.resolve(["content": NSNull(), "source": NSNull()])
            return
        }

        if let content = defaults.string(forKey: Self.pendingContentKey) {
            // Clear after reading (consume)
            clearPendingContent()

            invoke.resolve([
                "content": content,
                "source": "ios"
            ])
        } else {
            invoke.resolve(["content": NSNull(), "source": NSNull()])
        }
    }

    /// Check if there's pending content
    @objc public func hasPendingContent(_ invoke: Invoke) throws {
        guard let defaults = UserDefaults(suiteName: Self.appGroupId),
              let _ = defaults.string(forKey: Self.pendingContentKey) else {
            invoke.resolve(["hasPending": false])
            return
        }
        invoke.resolve(["hasPending": true])
    }

    /// Clear pending content without processing
    @objc public func clearPendingContent(_ invoke: Invoke) throws {
        clearPendingContent()
        invoke.resolve([:])
    }
}
```

### Package.swift
**File**: `ios/Package.swift`

```swift
// swift-tools-version:5.9
import PackageDescription

let package = Package(
    name: "tauri-plugin-share-intent",
    platforms: [
        .iOS(.v14)
    ],
    products: [
        .library(
            name: "tauri-plugin-share-intent",
            targets: ["ShareIntentPlugin"]
        )
    ],
    dependencies: [
        .package(name: "Tauri", path: "../.tauri/tauri-api")
    ],
    targets: [
        .target(
            name: "ShareIntentPlugin",
            dependencies: [
                .product(name: "Tauri", package: "Tauri")
            ],
            path: "Sources/ShareIntentPlugin"
        )
    ]
)
```

### Share Extension Target

The Share Extension is a **separate iOS app extension target**. It needs to be added to the Xcode project.

#### ShareViewController.swift
**File**: `ios/ShareExtension/ShareViewController.swift`

```swift
import UIKit
import Social
import MobileCoreServices
import UniformTypeIdentifiers

class ShareViewController: SLComposeServiceViewController {

    private static let appGroupId = "group.com.decentpaste.application"
    private static let pendingContentKey = "shareIntent_pendingContent"
    private static let pendingTimestampKey = "shareIntent_timestamp"

    // MARK: - Lifecycle

    override func isContentValid() -> Bool {
        // Validate that we have text content
        return !contentText.isEmpty || hasAttachmentOfType(UTType.plainText)
    }

    override func didSelectPost() {
        // Get shared text content
        extractTextContent { [weak self] text in
            guard let self = self, let text = text else {
                self?.extensionContext?.completeRequest(returningItems: nil, completionHandler: nil)
                return
            }

            // Combine with any text from compose box
            var fullText = text
            if !self.contentText.isEmpty {
                fullText = "\(self.contentText)\n\n\(text)"
            }

            // Store in shared container
            self.storeSharedContent(fullText)

            // Open main app (optional - may not work in all cases)
            self.openMainApp()

            // Complete the extension
            self.extensionContext?.completeRequest(returningItems: nil, completionHandler: nil)
        }
    }

    override func configurationItems() -> [Any]! {
        // Add configuration items if needed
        return []
    }

    // MARK: - Content Extraction

    private func hasAttachmentOfType(_ type: UTType) -> Bool {
        guard let extensionItem = extensionContext?.inputItems.first as? NSExtensionItem,
              let attachments = extensionItem.attachments else {
            return false
        }
        return attachments.contains { $0.hasItemConformingToTypeIdentifier(type.identifier) }
    }

    private func extractTextContent(completion: @escaping (String?) -> Void) {
        guard let extensionItem = extensionContext?.inputItems.first as? NSExtensionItem,
              let itemProvider = extensionItem.attachments?.first else {
            completion(contentText.isEmpty ? nil : contentText)
            return
        }

        // Try to get plain text
        if itemProvider.hasItemConformingToTypeIdentifier(UTType.plainText.identifier) {
            itemProvider.loadItem(forTypeIdentifier: UTType.plainText.identifier, options: nil) { item, error in
                if let text = item as? String {
                    completion(text)
                } else {
                    completion(nil)
                }
            }
        } else if itemProvider.hasItemConformingToTypeIdentifier(UTType.url.identifier) {
            // Handle URLs as text
            itemProvider.loadItem(forTypeIdentifier: UTType.url.identifier, options: nil) { item, error in
                if let url = item as? URL {
                    completion(url.absoluteString)
                } else {
                    completion(nil)
                }
            }
        } else {
            completion(contentText.isEmpty ? nil : contentText)
        }
    }

    // MARK: - Storage

    private func storeSharedContent(_ content: String) {
        guard let defaults = UserDefaults(suiteName: Self.appGroupId) else {
            print("[ShareExtension] Failed to access App Group defaults")
            return
        }

        defaults.set(content, forKey: Self.pendingContentKey)
        defaults.set(Date(), forKey: Self.pendingTimestampKey)
        defaults.synchronize()

        print("[ShareExtension] Stored content: \(content.prefix(50))...")
    }

    // MARK: - Open Main App

    private func openMainApp() {
        // Try to open main app via URL scheme
        // Note: This may not work reliably from extensions
        guard let url = URL(string: "decentpaste://share") else { return }

        // Use the responder chain to find the application
        var responder: UIResponder? = self
        while responder != nil {
            if let application = responder as? UIApplication {
                application.open(url, options: [:], completionHandler: nil)
                break
            }
            responder = responder?.next
        }
    }
}
```

#### Info.plist for Share Extension
**File**: `ios/ShareExtension/Info.plist`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDisplayName</key>
    <string>Share to DecentPaste</string>
    <key>CFBundleExecutable</key>
    <string>$(EXECUTABLE_NAME)</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundlePackageType</key>
    <string>XPC!</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>
    <key>NSExtension</key>
    <dict>
        <key>NSExtensionPointIdentifier</key>
        <string>com.apple.share-services</string>
        <key>NSExtensionPrincipalClass</key>
        <string>$(PRODUCT_MODULE_NAME).ShareViewController</string>
        <key>NSExtensionAttributes</key>
        <dict>
            <key>NSExtensionActivationRule</key>
            <dict>
                <key>NSExtensionActivationSupportsText</key>
                <true/>
                <key>NSExtensionActivationSupportsWebURLWithMaxCount</key>
                <integer>1</integer>
            </dict>
        </dict>
    </dict>
</dict>
</plist>
```

#### Entitlements for Share Extension
**File**: `ios/ShareExtension/ShareExtension.entitlements`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.application-groups</key>
    <array>
        <string>group.com.decentpaste.application</string>
    </array>
</dict>
</plist>
```

### Main App Configuration for iOS

The main app needs these additions:

#### URL Scheme
Add to `Info.plist`:
```xml
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>decentpaste</string>
        </array>
        <key>CFBundleURLName</key>
        <string>com.decentpaste.application</string>
    </dict>
</array>
```

#### App Groups Entitlement
Add to main app's entitlements:
```xml
<key>com.apple.security.application-groups</key>
<array>
    <string>group.com.decentpaste.application</string>
</array>
```

---

## 7. Rust Plugin Core

### lib.rs
**File**: `src/lib.rs`

```rust
use tauri::{
    plugin::{Builder, TauriPlugin},
    Manager, Runtime,
};

mod commands;
mod error;

pub use error::Error;
pub type Result<T> = std::result::Result<T, Error>;

/// Share intent content received from native platform
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct ShareIntentContent {
    pub content: Option<String>,
    pub source: Option<String>,  // "android" or "ios"
}

/// Initialize the share-intent plugin
pub fn init<R: Runtime>() -> TauriPlugin<R> {
    Builder::new("share-intent")
        .invoke_handler(tauri::generate_handler![
            commands::get_pending_content,
            commands::has_pending_content,
            commands::clear_pending_content,
        ])
        .setup(|app, api| {
            // Register platform-specific plugin implementations

            #[cfg(target_os = "android")]
            {
                api.register_android_plugin(
                    "com.decentpaste.plugins.shareintent",
                    "ShareIntentPlugin",
                )?;
            }

            #[cfg(target_os = "ios")]
            {
                // iOS plugin registration happens via Swift Package
                // The plugin is automatically registered when the Swift package is linked
            }

            Ok(())
        })
        .on_event(|app, event| {
            // Handle app lifecycle events if needed
            match event {
                tauri::RunEvent::Resumed => {
                    // App came to foreground - native plugins will check for content
                    log::info!("share-intent: App resumed");
                }
                _ => {}
            }
        })
        .build()
}
```

### commands.rs
**File**: `src/commands.rs`

```rust
use tauri::command;

use crate::{Result, ShareIntentContent};

/// Get and consume pending share intent content.
///
/// This command is primarily implemented by native code (Kotlin/Swift).
/// The Rust side just provides the interface.
///
/// Returns the shared content if present, consuming it so subsequent calls return None.
#[command]
pub async fn get_pending_content() -> Result<ShareIntentContent> {
    // This will be handled by native plugin via Tauri's mobile plugin system
    // For desktop (where share intents don't exist), return empty
    Ok(ShareIntentContent {
        content: None,
        source: None,
    })
}

/// Check if there's pending share content without consuming it.
#[command]
pub async fn has_pending_content() -> Result<bool> {
    // Handled by native plugin
    Ok(false)
}

/// Clear pending content without processing.
/// Useful for cancellation flows.
#[command]
pub async fn clear_pending_content() -> Result<()> {
    // Handled by native plugin
    Ok(())
}
```

### error.rs
**File**: `src/error.rs`

```rust
use serde::{Serialize, Serializer};

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Failed to access share intent: {0}")]
    AccessError(String),

    #[error("No pending share content")]
    NoPendingContent,

    #[error("Platform not supported")]
    PlatformNotSupported,
}

impl Serialize for Error {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(self.to_string().as_ref())
    }
}
```

### permissions/default.toml
**File**: `permissions/default.toml`

```toml
[default]
description = "Default permissions for share-intent plugin"
commands.allow = [
    "get_pending_content",
    "has_pending_content",
    "clear_pending_content"
]
```

---

## 8. App Integration

### Add Plugin Dependency
**File**: `decentpaste-app/src-tauri/Cargo.toml`

Add to `[dependencies]`:
```toml
tauri-plugin-share-intent = { path = "./plugins/tauri-plugin-share-intent" }
```

### Register Plugin
**File**: `decentpaste-app/src-tauri/src/lib.rs`

Add to the plugin chain:
```rust
let builder = tauri::Builder::default()
    .plugin(tauri_plugin_opener::init())
    .plugin(tauri_plugin_clipboard_manager::init())
    // ... other plugins ...
    .plugin(tauri_plugin_share_intent::init())  // Add this line
```

### Add Capability
**File**: `decentpaste-app/src-tauri/capabilities/default.json`

Add to permissions array:
```json
{
    "permissions": [
        "core:default",
        "clipboard-manager:default",
        "share-intent:default"  // Add this
    ]
}
```

---

## 9. Frontend Integration

### Add Event Listener
**File**: `decentpaste-app/src/main.ts`

Add at the top of the file:
```typescript
import {listen} from '@tauri-apps/api/event';
```

Add after `initApp(root)`:
```typescript
// Listen for share intents from mobile platforms
listen<{content: string; source: string}>('share-intent-received', async (event) => {
    console.log('Share intent received:', event.payload);
    await handleShareIntent(event.payload.content);
});

// Also check on visibility change (for iOS App Groups pattern)
// The existing visibilitychange handler should call checkPendingShareIntent()
```

Add handler function:
```typescript
// Store pending share content for after vault unlock
let pendingShareContent: string | null = null;

/**
 * Handle shared content from another app.
 * If vault is locked, stores for later. If unlocked, shares immediately.
 */
async function handleShareIntent(content: string): Promise<void> {
    if (!content || content.trim() === '') {
        console.log('Empty share intent, ignoring');
        return;
    }

    const vaultStatus = store.get('vaultStatus');
    console.log(`Processing share intent, vault status: ${vaultStatus}`);

    if (vaultStatus !== 'Unlocked') {
        // Store for later processing after unlock
        pendingShareContent = content;
        store.addToast('Unlock to share content with your devices', 'info');
        console.log('Stored share intent for after unlock');
        return;
    }

    // Vault is unlocked, process immediately
    await processShareIntentContent(content);
}

/**
 * Actually share the content with paired devices.
 */
async function processShareIntentContent(content: string): Promise<void> {
    try {
        // Reconnect to peers first (important for mobile resume)
        console.log('Reconnecting to peers...');
        await commands.reconnectPeers();

        // Small delay for reconnection
        await new Promise(resolve => setTimeout(resolve, 500));

        // Share the content
        console.log('Sharing content with peers...');
        await commands.shareClipboardContent(content);

        store.addToast('Content shared with your devices!', 'success');
        console.log('Share intent processed successfully');

    } catch (error) {
        console.error('Failed to process share intent:', error);
        const message = error instanceof Error ? error.message : 'Unknown error';

        if (message.includes('No paired peers')) {
            store.addToast('No paired devices to share with', 'error');
        } else {
            store.addToast(`Failed to share: ${message}`, 'error');
        }
    }
}

/**
 * Check for pending share content (used after vault unlock).
 * Call this from the vault status change handler.
 */
export async function checkPendingShareContent(): Promise<void> {
    if (pendingShareContent) {
        const content = pendingShareContent;
        pendingShareContent = null;
        await processShareIntentContent(content);
    }
}
```

### Handle After Vault Unlock
**File**: `decentpaste-app/src/app.ts`

In the vault status event handler (around line where `vaultStatus` event is handled):
```typescript
// Listen for vault status changes
eventManager.on('vault-status', async (status) => {
    const previousStatus = store.get('vaultStatus');
    store.set('vaultStatus', status);

    // If just unlocked, check for pending share intent
    if (status === 'Unlocked' && previousStatus !== 'Unlocked') {
        await this.loadDataAfterUnlock();

        // Process any pending share intent
        // Import checkPendingShareContent from main.ts
        setTimeout(async () => {
            const { checkPendingShareContent } = await import('./main');
            await checkPendingShareContent();
        }, 1000);  // Delay to ensure network is ready
    }
});
```

### Add Command Wrappers (Optional)
**File**: `decentpaste-app/src/api/commands.ts`

```typescript
import {invoke} from '@tauri-apps/api/core';

interface ShareIntentContent {
    content: string | null;
    source: string | null;
}

/**
 * Get and consume pending share intent content.
 */
export async function getPendingShareContent(): Promise<ShareIntentContent> {
    return invoke('plugin:share-intent|get_pending_content');
}

/**
 * Check if there's pending share content.
 */
export async function hasPendingShareContent(): Promise<boolean> {
    const result = await invoke<{hasPending: boolean}>('plugin:share-intent|has_pending_content');
    return result.hasPending;
}

/**
 * Clear pending share content without processing.
 */
export async function clearPendingShareContent(): Promise<void> {
    return invoke('plugin:share-intent|clear_pending_content');
}
```

---

## 10. Testing

### Android Testing

#### Using ADB
```bash
# Test cold start (app not running)
adb shell am start -a android.intent.action.SEND -t "text/plain" \
  --es android.intent.extra.TEXT "Hello from share test" \
  -n com.decentpaste.application/.MainActivity

# Test warm start (kill app UI first, then run same command)
# The app should resume and handle the share

# Test with longer text
adb shell am start -a android.intent.action.SEND -t "text/plain" \
  --es android.intent.extra.TEXT "This is a longer test message that should be shared across all paired devices via the DecentPaste application." \
  -n com.decentpaste.application/.MainActivity
```

#### Manual Testing
1. Install the app on an Android device
2. Open Chrome/Firefox and navigate to any page
3. Select text and tap "Share"
4. Choose "DecentPaste" from the share menu
5. Verify:
   - App opens (or comes to foreground)
   - Toast shows "Content shared with X devices" (if vault unlocked)
   - Toast shows "Unlock to share content" (if vault locked)
   - After unlock, content is automatically shared

### iOS Testing

#### Simulator Testing
1. Build and run the app with Share Extension
2. Open Safari in the simulator
3. Navigate to any page, select text
4. Tap Share icon, choose "Share to DecentPaste"
5. Verify extension appears and content is stored

#### Device Testing
1. Install app via Xcode (must be signed with proper entitlements)
2. Open Notes app, type some text, select it
3. Tap Share, choose "Share to DecentPaste"
4. Verify:
   - Extension UI appears
   - App opens after sharing
   - Content is shared to paired devices

### Edge Cases to Test

| Scenario | Expected Behavior |
|----------|-------------------|
| Vault not setup | Store content, show onboarding, share after setup |
| Vault locked | Store content, show unlock, share after unlock |
| No paired peers | Show error: "No paired devices to share with" |
| Content > 1MB | Show error: "Content too large (max 1MB)" |
| Network disconnected | Attempt reconnect, retry, show error if fails |
| Share while pairing | Queue content, process after pairing completes |
| Rapid multiple shares | Handle debouncing, only share latest |
| Cold start on iOS | Extension writes, app reads on launch |
| Warm start on iOS | Extension writes, app reads on become active |

---

## 11. Implementation Checklist

### Phase 1: Plugin Setup
- [ ] Create plugin directory structure
- [ ] Create `Cargo.toml` with dependencies
- [ ] Create `build.rs` for Tauri plugin
- [ ] Create `src/lib.rs` with plugin init
- [ ] Create `src/commands.rs` with command stubs
- [ ] Create `src/error.rs` with error types
- [ ] Create `permissions/default.toml`

### Phase 2: Android Implementation
- [ ] Create `android/build.gradle.kts`
- [ ] Create `android/src/main/AndroidManifest.xml` with intent filter
- [ ] Create `ShareIntentPlugin.kt` with:
  - [ ] `load()` method for cold start
  - [ ] `onNewIntent()` for warm start
  - [ ] `getPendingContent` command
  - [ ] `hasPendingContent` command
  - [ ] `clearPendingContent` command
- [ ] Create `proguard-rules.pro`
- [ ] Test on Android device

### Phase 3: App Integration
- [ ] Add plugin to `Cargo.toml`
- [ ] Register plugin in `lib.rs`
- [ ] Add capability to `default.json`
- [ ] Add event listener in `main.ts`
- [ ] Add `handleShareIntent` function
- [ ] Add `processShareIntentContent` function
- [ ] Add `checkPendingShareContent` export
- [ ] Modify vault unlock handler in `app.ts`
- [ ] Test full flow on Android

### Phase 4: iOS Implementation
- [ ] Create `ios/Package.swift`
- [ ] Create `ShareIntentPlugin.swift`
- [ ] Create `ShareExtension/` directory
- [ ] Create `ShareViewController.swift`
- [ ] Create `Info.plist` for extension
- [ ] Create `ShareExtension.entitlements`
- [ ] Add App Groups to main app entitlements
- [ ] Add URL scheme to main app Info.plist
- [ ] Add Share Extension target to Xcode project
- [ ] Test on iOS device

### Phase 5: Polish
- [ ] Add loading states during share
- [ ] Add analytics/logging
- [ ] Handle edge cases (see testing section)
- [ ] Update ARCHITECTURE.md
- [ ] Test on multiple devices

---

## Appendix: Common Issues

### Android: Share menu doesn't show DecentPaste
- Verify `AndroidManifest.xml` intent filter is correct
- Check that `android:exported="true"` is set
- Rebuild the app completely (`tauri android build`)

### Android: Content not received
- Check logcat for plugin logs: `adb logcat | grep ShareIntent`
- Verify `onNewIntent` is being called (add logging)
- Check that intent action is not being cleared prematurely

### iOS: Extension doesn't appear
- Verify extension target is properly added to project
- Check that extension bundle ID matches pattern: `com.decentpaste.application.share`
- Verify signing with correct team/provisioning profile

### iOS: Content not reaching main app
- Verify App Groups are configured on both targets
- Check that group identifier matches: `group.com.decentpaste.application`
- Add logging to extension to verify content is being stored
- Add logging to main app to verify it's checking the shared defaults

### Both: Vault locked handling
- Ensure content is stored before showing lock screen
- Verify `checkPendingShareContent` is called after unlock
- Add delay after unlock to allow network reconnection
