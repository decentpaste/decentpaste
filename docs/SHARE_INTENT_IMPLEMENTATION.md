# Share Intent Plugin Architecture

This document describes the architecture of the Share Intent plugin, which enables users to share text from any mobile app directly to DecentPaste via the OS share menu.

**Target Platforms**: Android and iOS

---

## Table of Contents

1. [Overview](#overview)
2. [Data Flow](#data-flow)
3. [Plugin Structure](#plugin-structure)
4. [Android Implementation](#android-implementation)
5. [iOS Implementation](#ios-implementation)
6. [Frontend Integration](#frontend-integration)
7. [Key Design Decisions](#key-design-decisions)

---

## Overview

### Goal

When a user selects text in any app and taps "Share" → "DecentPaste":
1. DecentPaste opens (cold start) or resumes (warm start)
2. The shared content triggers a `share-intent-received` event
3. Frontend handles the event, reconnects to peers if needed
4. Content is encrypted and broadcast to all paired devices
5. User sees confirmation toast

### Why a Tauri Plugin?

- The `gen/android/` and `gen/apple/` directories are **generated by Tauri** and can be regenerated
- Modifications to these directories would be lost on `tauri android init` or `tauri ios init`
- Tauri plugins include native code that gets **merged** into the build automatically
- This keeps all share intent logic isolated and maintainable

---

## Data Flow

```
┌─────────────────────────────────────────────────────────────────┐
│                          OTHER APP                               │
│                     (User selects text)                          │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                        OS SHARE MENU                             │
│                  (User selects DecentPaste)                      │
└─────────────────────────────────────────────────────────────────┘
                                │
         ┌──────────────────────┴──────────────────────┐
         ▼                                             ▼
┌─────────────────────┐                  ┌─────────────────────────┐
│      ANDROID        │                  │          iOS            │
│  ShareIntentPlugin  │                  │   Share Extension +     │
│     (Kotlin)        │                  │   ShareIntentPlugin     │
└─────────────────────┘                  └─────────────────────────┘
         │                                             │
         │ onNewIntent / onCreate                      │ App Groups
         │ ACTION_SEND                                 │ UserDefaults
         ▼                                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                      PLUGIN RUST CORE                            │
│                  tauri-plugin-share-intent                       │
│                                                                  │
│   • Emits "share-intent-received" event to frontend              │
│   • Provides get_pending_content command (fallback)              │
└─────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                     FRONTEND (TypeScript)                        │
│                        main.ts / app.ts                          │
│                                                                  │
│   listen('share-intent-received') → handleShareIntent(content)  │
└─────────────────────────────────────────────────────────────────┘
                                │
                 ┌──────────────┴──────────────┐
                 ▼                             ▼
       ┌─────────────────┐           ┌─────────────────┐
       │  VAULT LOCKED   │           │ VAULT UNLOCKED  │
       └─────────────────┘           └─────────────────┘
                 │                             │
                 ▼                             ▼
       Store pending content          Reconnect peers
       Show unlock screen                     ▼
       ─────────────────►             Call share_clipboard_content
       After unlock, process                  ▼
                                      Show success toast
                                      "Content shared!"
```

### Two Launch Scenarios

**Cold Start** (app not running):
1. Android: `onCreate()` receives intent with `ACTION_SEND`
2. iOS: Extension writes to App Groups, main app reads on launch
3. Plugin emits event after WebView loads (500ms delay for stability)
4. Frontend handles event

**Warm Start** (app in background):
1. Android: `onNewIntent()` receives intent
2. iOS: Main app checks App Groups on `applicationDidBecomeActive`
3. Plugin emits event immediately
4. Frontend handles event

---

## Plugin Structure

```
decentpaste-app/src-tauri/plugins/tauri-plugin-share-intent/
├── Cargo.toml                    # Rust dependencies
├── build.rs                      # Tauri plugin build script
├── src/
│   ├── lib.rs                    # Plugin initialization
│   ├── commands.rs               # Command stubs (native handles actual logic)
│   └── error.rs                  # Error types
├── android/
│   ├── build.gradle.kts          # Android library config
│   ├── proguard-rules.pro        # ProGuard rules
│   └── src/main/
│       ├── AndroidManifest.xml   # Intent filter via activity-alias
│       └── kotlin/.../ShareIntentPlugin.kt  # Main Android implementation
├── ios/
│   ├── Package.swift             # Swift package definition
│   ├── Sources/ShareIntentPlugin/
│   │   └── ShareIntentPlugin.swift    # Main iOS plugin
│   └── ShareExtension/           # iOS Share Extension (separate target)
│       ├── Info.plist
│       ├── ShareExtension.entitlements
│       └── ShareViewController.swift
└── permissions/
    └── default.toml              # Tauri capability permissions
```

---

## Android Implementation

### Intent Filter (AndroidManifest.xml)

Uses `activity-alias` to add share intent handling to the main activity:

```xml
<activity-alias
    android:name="${applicationId}.ShareReceiverAlias"
    android:targetActivity="${applicationId}.MainActivity"
    android:exported="true"
    android:label="DecentPaste">
    <intent-filter>
        <action android:name="android.intent.action.SEND" />
        <category android:name="android.intent.category.DEFAULT" />
        <data android:mimeType="text/plain" />
    </intent-filter>
</activity-alias>
```

### ShareIntentPlugin.kt

Key implementation details:

```kotlin
@TauriPlugin
class ShareIntentPlugin(private val activity: Activity) : Plugin(activity) {

    // Store pending content for retrieval via command
    private var pendingContent: String? = null

    // Track processed intents by identity hash (not content)
    // This allows same text to be shared multiple times
    private var lastProcessedIntentHash: Int = 0

    override fun load(webView: WebView) {
        handleIntent(activity.intent)  // Cold start
    }

    override fun onNewIntent(intent: Intent) {
        handleIntent(intent)  // Warm start
    }

    private fun handleIntent(intent: Intent?) {
        if (intent?.action == Intent.ACTION_SEND && intent.type == "text/plain") {
            val sharedText = intent.getStringExtra(Intent.EXTRA_TEXT)

            // Use identity hash to detect same intent being reprocessed
            // (happens on config changes like rotation)
            val intentHash = System.identityHashCode(intent)
            if (intentHash == lastProcessedIntentHash) return
            lastProcessedIntentHash = intentHash

            pendingContent = sharedText

            // Emit event to frontend (500ms delay for WebView readiness)
            Handler(Looper.getMainLooper()).postDelayed({
                emitEvent("share-intent-received", sharedText, "android")
            }, 500)
        }

        // Clear action to prevent re-processing
        intent?.action = null
    }
}
```

### Event Emission

The plugin emits events via JavaScript evaluation with fallbacks:

1. `window.__TAURI__.event.emit()` - Primary Tauri v2 method
2. `window.__TAURI_INTERNALS__.invoke()` - Fallback
3. `window.dispatchEvent(CustomEvent)` - Last resort DOM event

---

## iOS Implementation

iOS requires two components due to platform restrictions:

### 1. Share Extension (ShareViewController.swift)

Runs in a **separate process** with limited capabilities:
- 120MB memory limit
- No access to main app's sandbox
- Cannot directly communicate with main app

Stores shared content in App Groups shared storage:

```swift
class ShareViewController: SLComposeServiceViewController {
    private static let appGroupId = "group.com.decentpaste.application"

    override func didSelectPost() {
        extractTextContent { text in
            // Store in shared UserDefaults
            let defaults = UserDefaults(suiteName: Self.appGroupId)
            defaults?.set(text, forKey: "shareIntent_pendingContent")
            defaults?.set(Date(), forKey: "shareIntent_timestamp")
            defaults?.synchronize()

            self.extensionContext?.completeRequest(returningItems: nil)
        }
    }
}
```

### 2. Main App Plugin (ShareIntentPlugin.swift)

Reads from App Groups and emits events:

```swift
class ShareIntentPlugin: Plugin {
    // Track by timestamp to allow same content to be shared multiple times
    private var lastProcessedTimestamp: Date?

    override func load(webview: WKWebView) {
        // Register for app lifecycle
        NotificationCenter.default.addObserver(
            self, selector: #selector(applicationDidBecomeActive),
            name: UIApplication.didBecomeActiveNotification, object: nil
        )
        checkPendingContent()  // Cold start
    }

    @objc func applicationDidBecomeActive() {
        checkPendingContent()  // Warm start
    }

    private func checkPendingContent() {
        let defaults = UserDefaults(suiteName: "group.com.decentpaste.application")
        guard let content = defaults?.string(forKey: "shareIntent_pendingContent"),
              let timestamp = defaults?.object(forKey: "shareIntent_timestamp") as? Date
        else { return }

        // Expire after 5 minutes
        if timestamp < Date().addingTimeInterval(-300) {
            clearPendingContent()
            return
        }

        // Use timestamp for duplicate detection
        if let lastProcessed = lastProcessedTimestamp, timestamp <= lastProcessed {
            return
        }
        lastProcessedTimestamp = timestamp

        trigger("share-intent-received", data: ["content": content, "source": "ios"])
    }
}
```

---

## Frontend Integration

### Event Listener (main.ts)

```typescript
// Listen for share intents from mobile platforms
if (isMobile()) {
    // Primary: Tauri event system
    listen<{ content: string; source: string }>('share-intent-received', async (event) => {
        await handleShareIntent(event.payload.content);
    });

    // Fallback: DOM CustomEvent
    window.addEventListener('share-intent-received', async (event: Event) => {
        const customEvent = event as CustomEvent<{ content: string; source: string }>;
        if (customEvent.detail?.content) {
            await handleShareIntent(customEvent.detail.content);
        }
    });
}
```

### Share Intent Handler

```typescript
async function handleShareIntent(content: string): Promise<void> {
    const vaultStatus = store.get('vaultStatus');

    if (vaultStatus !== 'Unlocked') {
        // Store for later, show unlock prompt
        pendingShareContent = content;
        store.addToast('Unlock to share content with your devices', 'info');
        return;
    }

    // Process immediately
    await processShareIntentContent(content);
}

async function processShareIntentContent(content: string): Promise<void> {
    await reconnectPeers();  // Important for mobile resume
    await new Promise(resolve => setTimeout(resolve, 500));  // Allow reconnection
    await shareClipboardContent(content);
    store.addToast('Content shared with your devices!', 'success');
}
```

### After Vault Unlock (app.ts)

```typescript
// In vault status change handler
if (status === 'Unlocked' && previousStatus !== 'Unlocked') {
    setTimeout(async () => {
        const { checkPendingShareContent } = await import('./main');
        await checkPendingShareContent();
    }, 1000);  // Delay for network readiness
}
```

---

## Key Design Decisions

### 1. Event-Based vs Command-Based

**Decision**: Event-based as primary, commands as fallback

**Rationale**: Events are pushed from native code immediately when share intent is received. Commands require polling. The event approach provides better UX with immediate response.

### 2. Identity-Based Duplicate Detection

**Decision**: Track intent identity (Android) or timestamp (iOS), not content value

**Rationale**: Content-based detection would prevent users from sharing the same text twice. By tracking the intent object's identity hash (Android) or share timestamp (iOS), we correctly detect config-change reprocessing while allowing intentional duplicate shares.

**Implementation**:
- **Android**: `System.identityHashCode(intent)` - Same Intent object on config changes has same hash
- **iOS**: `Date()` timestamp from Share Extension - Each share action gets a new timestamp

### 3. 500ms WebView Delay

**Decision**: Delay event emission by 500ms after plugin load

**Rationale**: On cold start, the WebView may not be fully ready to receive events. The delay ensures the JavaScript event system is initialized.

### 4. App Groups for iOS

**Decision**: Use App Groups + UserDefaults for extension-to-app communication

**Rationale**: iOS Share Extensions run in a separate process with no direct IPC. App Groups provide a shared storage container that both processes can access.

### 5. 5-Minute Content Expiry (iOS)

**Decision**: Expire shared content after 5 minutes

**Rationale**: Content stored in App Groups persists across app launches. Without expiry, old content could be mistakenly processed. 5 minutes is long enough to handle normal share flows.

### 6. Activity-Alias for Android

**Decision**: Use `activity-alias` instead of modifying MainActivity

**Rationale**: The `gen/android/` directory is generated by Tauri. Using activity-alias in the plugin's manifest merges the intent filter without modifying generated code.

---

## Edge Cases

| Scenario | Expected Behavior |
|----------|-------------------|
| Vault not setup | Store content, show onboarding, share after setup |
| Vault locked | Store content, show unlock screen, share after unlock |
| No paired peers | Show error: "No paired devices to share with" |
| Content > 1MB | Show error: "Content too large (max 1MB)" |
| Network disconnected | Attempt reconnect, retry, show error if fails |
| Same text shared twice | Both shares are processed (identity-based tracking) |
| Config change (rotation) | Same intent is not reprocessed |
| iOS content > 5 min old | Content is cleared, not processed |
