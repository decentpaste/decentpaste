//! Internet Pairing Code System
//!
//! This module implements the pairing code system for internet-based device pairing.
//! Pairing codes are short-lived, single-use tokens that allow two devices to discover
//! each other through a relay server without exposing themselves via global DHT.
//!
//! # Security Properties
//!
//! - **128-bit token entropy**: Cryptographically random, brute-force infeasible
//! - **5-minute expiration**: Limits attack window
//! - **Single-use**: Atomic invalidation prevents race conditions
//! - **8-digit PIN verification**: 1:100,000,000 MITM probability (same as local pairing)
//!
//! # Code Format
//!
//! Full code: `dp://relay-address#peer-id#token` (uses `#` delimiter since Multiaddrs contain `/`)
//! Display code: `XXXX-XXXX` (8 Base32 chars derived from token)
//!
//! Example: `dp:///ip4/xx.xx.xx.xx/tcp/4001/p2p/12D3KooW...#12D3KooWPeer...#a1b2c3d4e5f6...`

use chrono::{DateTime, Duration, Utc};
use data_encoding::BASE32_NOPAD;
use rand::Rng;
use serde::{Deserialize, Serialize};
use std::sync::atomic::{AtomicBool, Ordering};

use crate::error::{DecentPasteError, Result};

/// Pairing code expiration time in seconds (5 minutes)
pub const PAIRING_CODE_EXPIRY_SECS: i64 = 300;

/// Pairing session timeout in seconds (2 minutes) - universal for all platforms
/// Reserved for future use in relay lookup service timeout handling.
#[allow(dead_code)]
pub const PAIRING_TIMEOUT_SECS: i64 = 120;

/// PIN digits for internet pairing (8 digits = 1:100,000,000)
/// Reserved for future use when generating PINs for internet pairing.
#[allow(dead_code)]
pub const PAIRING_PIN_DIGITS: usize = 8;

/// A pairing code for internet-based device discovery.
///
/// This code is generated by Device A and shared out-of-band (e.g., text, QR code)
/// with Device B. Device B uses the code to connect to Device A through a relay.
#[derive(Debug, Serialize, Deserialize)]
pub struct PairingCode {
    /// The relay server address (Multiaddr format)
    /// e.g., "/dns4/relay-us.decentpaste.com/tcp/4001/p2p/12D3KooW..."
    pub relay_address: String,

    /// Our peer ID (for the remote device to dial)
    pub peer_id: String,

    /// Cryptographically random token (128-bit)
    /// This ensures the code cannot be guessed even if peer_id is known
    pub token: [u8; 16],

    /// When this code was created
    pub created_at: DateTime<Utc>,

    /// When this code expires
    pub expires_at: DateTime<Utc>,

    /// Whether this code has been used (atomic for thread safety)
    #[serde(skip)]
    used: AtomicBool,
}

impl Clone for PairingCode {
    fn clone(&self) -> Self {
        Self {
            relay_address: self.relay_address.clone(),
            peer_id: self.peer_id.clone(),
            token: self.token,
            created_at: self.created_at,
            expires_at: self.expires_at,
            used: AtomicBool::new(self.used.load(Ordering::SeqCst)),
        }
    }
}

impl PairingCode {
    /// Generate a new pairing code.
    ///
    /// # Arguments
    /// * `relay_address` - The relay server Multiaddr
    /// * `peer_id` - Our libp2p PeerId
    pub fn new(relay_address: String, peer_id: String) -> Self {
        let mut rng = rand::rng();
        let mut token = [0u8; 16];
        rng.fill(&mut token);

        let now = Utc::now();
        let expires_at = now + Duration::seconds(PAIRING_CODE_EXPIRY_SECS);

        Self {
            relay_address,
            peer_id,
            token,
            created_at: now,
            expires_at,
            used: AtomicBool::new(false),
        }
    }

    /// Check if this code has expired.
    pub fn is_expired(&self) -> bool {
        Utc::now() > self.expires_at
    }

    /// Check if this code has been used.
    /// Reserved for future use in single-use code enforcement.
    #[allow(dead_code)]
    pub fn is_used(&self) -> bool {
        self.used.load(Ordering::SeqCst)
    }

    /// Mark this code as used. Returns true if this call marked it,
    /// false if it was already used (prevents race conditions).
    /// Reserved for future use in single-use code enforcement.
    #[allow(dead_code)]
    pub fn mark_used(&self) -> bool {
        // compare_exchange returns Ok if the swap succeeded
        self.used
            .compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
            .is_ok()
    }

    /// Get the full URI representation of this code.
    ///
    /// Format: `dp://relay-address#peer-id#token`
    ///
    /// Uses `#` as delimiter because Multiaddrs contain `/` characters.
    /// Example: `dp:///ip4/xx.xx.xx.xx/tcp/4001/p2p/12D3KooW...#12D3KooWPeer...#a1b2c3d4...`
    pub fn to_uri(&self) -> String {
        let token_hex = hex::encode(self.token);
        format!("dp://{}#{}#{}", self.relay_address, self.peer_id, token_hex)
    }

    /// Get the short display code (human-friendly).
    ///
    /// Format: `XXXX-XXXX` (8 Base32 chars)
    /// Derived from first 5 bytes of token (40 bits = 8 Base32 chars)
    pub fn to_display_code(&self) -> String {
        let encoded = BASE32_NOPAD.encode(&self.token[..5]);
        format!("{}-{}", &encoded[..4], &encoded[4..8])
    }

    /// Parse a pairing code from its URI representation.
    ///
    /// Format: `dp://relay-address#peer-id#token`
    ///
    /// Uses `#` as delimiter because Multiaddrs contain `/` characters.
    pub fn from_uri(uri: &str) -> Result<Self> {
        let uri = uri.trim();

        // Remove dp:// prefix
        let rest = uri
            .strip_prefix("dp://")
            .ok_or_else(|| DecentPasteError::InvalidInput("Invalid pairing code format".into()))?;

        // Split into parts: relay-address#peer-id#token
        // Using '#' as delimiter since Multiaddrs contain '/' characters
        let parts: Vec<&str> = rest.splitn(3, '#').collect();
        if parts.len() != 3 {
            return Err(DecentPasteError::InvalidInput(
                "Invalid pairing code format - expected relay#peer#token".into(),
            ));
        }

        let relay_address = parts[0].to_string();
        let peer_id = parts[1].to_string();
        let token_hex = parts[2];

        // Decode token
        let token_bytes = hex::decode(token_hex).map_err(|_| {
            DecentPasteError::InvalidInput("Invalid pairing code token".into())
        })?;

        if token_bytes.len() != 16 {
            return Err(DecentPasteError::InvalidInput(
                "Invalid pairing code token length".into(),
            ));
        }

        let mut token = [0u8; 16];
        token.copy_from_slice(&token_bytes);

        Ok(Self {
            relay_address,
            peer_id,
            token,
            created_at: Utc::now(), // We don't know when it was created
            expires_at: Utc::now(), // Will be validated by generator
            used: AtomicBool::new(false),
        })
    }

    /// Validate that the token matches (constant-time comparison).
    /// Reserved for future use when validating incoming pairing connections.
    #[allow(dead_code)]
    pub fn validate_token(&self, other_token: &[u8; 16]) -> bool {
        use subtle::ConstantTimeEq;
        self.token.ct_eq(other_token).into()
    }
}

/// Pairing code registry for tracking active codes.
///
/// This is kept in memory on the device that generated the code.
/// The relay server has its own registry for the lookup service.
#[derive(Debug, Default)]
pub struct PairingCodeRegistry {
    /// Active pairing codes (indexed by display code for local lookup)
    codes: std::collections::HashMap<String, PairingCode>,
}

impl PairingCodeRegistry {
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a new pairing code.
    pub fn register(&mut self, code: PairingCode) {
        let display = code.to_display_code();
        self.codes.insert(display, code);
    }

    /// Look up a code by display code.
    /// Reserved for future use in relay lookup service implementation.
    #[allow(dead_code)]
    pub fn get(&self, display_code: &str) -> Option<&PairingCode> {
        // Normalize: remove dash and uppercase
        let normalized = display_code.replace('-', "").to_uppercase();
        // Try both with and without dash
        self.codes
            .get(&format!(
                "{}-{}",
                &normalized[..4.min(normalized.len())],
                &normalized[4..8.min(normalized.len())]
            ))
            .or_else(|| self.codes.get(display_code))
    }

    /// Remove a code from the registry.
    pub fn remove(&mut self, display_code: &str) {
        let normalized = display_code.replace('-', "").to_uppercase();
        let key = format!(
            "{}-{}",
            &normalized[..4.min(normalized.len())],
            &normalized[4..8.min(normalized.len())]
        );
        self.codes.remove(&key);
        self.codes.remove(display_code);
    }

    /// Clean up expired codes.
    pub fn cleanup_expired(&mut self) {
        self.codes.retain(|_, code| !code.is_expired());
    }

    /// Get the number of active codes.
    /// Reserved for future use in registry management.
    #[allow(dead_code)]
    pub fn len(&self) -> usize {
        self.codes.len()
    }

    /// Check if registry is empty.
    /// Reserved for future use in registry management.
    #[allow(dead_code)]
    pub fn is_empty(&self) -> bool {
        self.codes.is_empty()
    }
}

/// Information needed to connect to a peer via pairing code.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PairingCodeInfo {
    /// The relay server address
    pub relay_address: String,
    /// The target peer ID
    pub peer_id: String,
    /// The pairing token (hex-encoded for serialization)
    pub token: [u8; 16],
}

impl From<&PairingCode> for PairingCodeInfo {
    fn from(code: &PairingCode) -> Self {
        Self {
            relay_address: code.relay_address.clone(),
            peer_id: code.peer_id.clone(),
            token: code.token,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pairing_code_generation() {
        let code = PairingCode::new(
            "/dns4/relay.example.com/tcp/4001/p2p/12D3KooW...".to_string(),
            "12D3KooWTest...".to_string(),
        );

        assert!(!code.is_expired());
        assert!(!code.is_used());

        let display = code.to_display_code();
        assert_eq!(display.len(), 9); // XXXX-XXXX
        assert!(display.contains('-'));
    }

    #[test]
    fn test_pairing_code_uri_roundtrip() {
        let original = PairingCode::new(
            "/dns4/relay.example.com/tcp/4001".to_string(),
            "12D3KooWTest".to_string(),
        );

        let uri = original.to_uri();
        let parsed = PairingCode::from_uri(&uri).unwrap();

        assert_eq!(original.relay_address, parsed.relay_address);
        assert_eq!(original.peer_id, parsed.peer_id);
        assert_eq!(original.token, parsed.token);
    }

    #[test]
    fn test_single_use_enforcement() {
        let code = PairingCode::new("relay".to_string(), "peer".to_string());

        assert!(code.mark_used()); // First use succeeds
        assert!(!code.mark_used()); // Second use fails
        assert!(code.is_used());
    }

    #[test]
    fn test_registry() {
        let mut registry = PairingCodeRegistry::new();

        let code = PairingCode::new("relay".to_string(), "peer".to_string());
        let display = code.to_display_code();

        registry.register(code);
        assert_eq!(registry.len(), 1);
        assert!(registry.get(&display).is_some());

        registry.remove(&display);
        assert!(registry.is_empty());
    }

    #[test]
    fn test_uri_with_full_multiaddr() {
        // Test with realistic Multiaddr that contains many '/' characters
        let relay_addr = "/ip4/xx.xx.xx.xx/tcp/4001/p2p/12D3KooWBXYY21wvUx2VHmwhCcZefeHriDGd9ExhubbfMzxiDMdZ";
        let peer_id = "12D3KooWTestPeer123456789";

        let code = PairingCode::new(relay_addr.to_string(), peer_id.to_string());
        let uri = code.to_uri();

        // Verify URI format uses '#' delimiter
        assert!(uri.starts_with("dp://"));
        assert!(uri.contains('#'));

        // Verify roundtrip works correctly
        let parsed = PairingCode::from_uri(&uri).unwrap();
        assert_eq!(parsed.relay_address, relay_addr);
        assert_eq!(parsed.peer_id, peer_id);
        assert_eq!(parsed.token, code.token);
    }
}
